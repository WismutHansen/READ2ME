import asyncio
import logging
from threading import Event, Thread
from database.crud import create_text
import database.state
from llm.LLM_calls import podcast, story, generate_title, tldr
from TTS.tts_engines import EdgeTTSEngine, F5TTSEngine
from TTS.tts_functions import PodcastGenerator
from utils.env import setup_env
from utils.history_handler import add_to_history, check_history
from utils.task_file_handler import clear_tasks, get_tasks
from utils.text_extraction import extract_text

output_dir, task_file, img_pth, sources_file = setup_env()


async def select_tts_engine(tts_engine):
    if tts_engine == "styletts2":
        from utils.synthesize_styletts2 import say_with_styletts2

        return say_with_styletts2
    elif tts_engine == "piper":
        from utils.synthesize_piper import url_with_piper

        return url_with_piper
    elif tts_engine == "F5":
        return F5TTSEngine("utils/voices/")
    else:
        return EdgeTTSEngine()


async def generate_and_export_audio(
    engine, text, title, tts_engine, output_dir, img_pth
):
    if isinstance(engine, (EdgeTTSEngine, F5TTSEngine)):
        voices = await engine.get_available_voices()
        voice = await engine.pick_random_voice(voices)
        audio, vtt_file = await engine.generate_audio(text, voice)
        await engine.export_audio(audio, text, title, vtt_file)
    else:
        await engine(text, title, output_dir, img_pth)


async def process_url_task(content, tts_engine):
    if await check_history(content):
        logging.info(f"URL {content} has already been processed. Skipping.")
        return

    try:
        text, title = await extract_text(content)
        engine = await select_tts_engine(tts_engine)
        await generate_and_export_audio(
            engine, text, title, tts_engine, output_dir, img_pth
        )
        await add_to_history(content)
    except Exception as e:
        logging.error(f"Error processing URL task: {e}")


async def process_text_task(content, tts_engine):
    title = generate_title(content)
    current_text = database.state.get_current_text()
    if current_text:
        current_text.text = content
        current_text.title = title
        create_text(current_text)

    try:
        engine = await select_tts_engine(tts_engine)
        await generate_and_export_audio(
            engine, content, title, tts_engine, output_dir, img_pth
        )
    except Exception as e:
        logging.error(f"Error processing text task: {e}")


async def process_podcast_task(content, tts_engine):
    try:
        text, title = await extract_text(content)
        script = podcast(text)
        if script:
            engine = await select_tts_engine(tts_engine)
            podcast_gen = PodcastGenerator(engine)
            await podcast_gen.create_podcast_audio(script)
            logging.info("Podcast audio created.")
    except Exception as e:
        logging.error(f"Error creating podcast: {e}")


async def process_tasks(stop_event):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    async def process():
        while not stop_event.is_set():
            tasks = await get_tasks()
            if tasks:
                logging.info(f"Tasks retrieved: {tasks}")

            for task in tasks:
                task_type = task.get("type")
                content = task.get("content")
                tts_engine = task.get("tts_engine")
                task_action = task.get("task")

                if not all([task_type, content, tts_engine]):
                    logging.error(f"Invalid task format: {task}")
                    continue

                try:
                    if task_type == "url":
                        await process_url_task(content, tts_engine)
                    elif task_type == "text":
                        await process_text_task(content, tts_engine)
                    elif task_type == "podcast":
                        await process_podcast_task(content, tts_engine)
                    elif task_type == "story":
                        # Additional handling for story tasks
                        pass
                    else:
                        logging.error(f"Unknown task type: {task_type}")
                except Exception as e:
                    logging.error(f"Unhandled exception processing task {task}: {e}")

            if tasks:
                await clear_tasks()
            await asyncio.sleep(5)

    loop.run_until_complete(process())


def start_task_processor(stop_event):
    thread = Thread(target=process_tasks, args=(stop_event,))
    thread.daemon = True
    thread.start()
    return thread
